#include "qemu/osdep.h"
#include "qapi/error.h"
#include "qemu/cutils.h"
#include "qemu/error-report.h"
#include "qemu/module.h"
#include "hw/usb.h"
#include "desc.h"

// avoiding some annoying redefine warnings
#ifdef ARRAY_SIZE
#undef ARRAY_SIZE
#undef FALSE
#undef TRUE
#endif

// SPDM includes
#pragma GCC diagnostic ignored "-Wundef"
#include <base.h>
#include <library/memlib.h>
#include <library/spdm_common_lib.h>
#include <library/spdm_responder_lib.h>
#include <library/spdm_transport_mctp_lib.h>
#include "spdm_common_lib_internal.h"
#include "spdm_device_secret_lib_internal.h"
#include <../library/spdm_secured_message_lib/spdm_secured_message_lib_internal.h>
#include "mctp.h"
#pragma GCC diagnostic pop

// perf includes
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <asm/unistd.h>
#include <unistd.h>

#define TOTP_TIMESTEP 30            // Timestep for TOTP checks (must be the same in totp_spdm_driver.c)

#define SPDMDEV_MAX_BUF (4096*4)    // Max size for SPDM buffer
#define MAX_PACKET_SIZE 64          // Max packet size in USB transfer
#define TOTP_HEX_SIZE 6             // TOTP header size in bytes
#define LEN_HEX_SIZE 4              // SPDM length header size in byes
#define SPDM_SEND_OFFSET 4          // LEN_HEX_SIZE
#define TOTP_RANDOM_NUM_SIZE 16     // Size of TOTP random number for key generation in bytes
#define SPDM_SHA_SIZE SHA256_DIGEST_SIZE // Size of TOTP key generated by hashing
#define TOTP_KEY_FROM_MS    1       // if 0 derives key from random numbers, else uses master secret from the session

#define USB_SPDM_DEBUG 0            // Enables/disables SPDM debug messages

#if USB_SPDM_DEBUG
#define USB_SPDM_PRINT(format,  ...) printf(format, ##__VA_ARGS__)
#else
#define USB_SPDM_PRINT(format,  ...)
#endif /* USB_SPDM_DEBUG */

/* 
* Struct containing global information about the device
*/
typedef struct {
    USBDevice dev;
    uint8_t data[MAX_PACKET_SIZE];
    QemuThread spdm_io_thread;
    void *spdm_context;
    uint32_t extra_buffer_in[SPDM_SEND_OFFSET];
    uint32_t current_transfer_size_in;
    uint32_t extra_buffer_out[LEN_HEX_SIZE];
    uint32_t current_transfer_size_out;
    uint32_t full_transfer_size_out;
} USBTotpSpdmState;

/*
* Global SPDM variables
*/
static QemuMutex spdm_io_mutex;
static QemuCond spdm_io_cond;
static uint8_t spdm_buf[SPDMDEV_MAX_BUF];
static uint32_t spdm_buf_size;
static int spdm_send_is_ready;
static int spdm_receive_is_ready;
static uint8_t totp_key[SPDM_SHA_SIZE]; // 8 bytes
static bool current_spdm_receive_message;
static bool next_message_totp_check;

/* 
* Global SPDM device options
*/
static uint8_t  totp_spdm_m_support_measurement_spec =
    SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF;

static uint32_t totp_spdm_m_support_hash_algo =
    SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384 |
    SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256;

static uint32_t totp_spdm_m_support_measurement_hash_algo =
    SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_512 |
    SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_384;

static uint32_t totp_spdm_m_support_asym_algo =
    SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384 |
    SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256;

static uint16_t totp_spdm_m_support_req_asym_algo =
    SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072 |
    SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048 |
    SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072 |
    SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048;

static uint16_t totp_spdm_m_support_dhe_algo =
    SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_384_R1 |
    SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_256_R1 |
    SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_3072 |
    SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_2048;

static uint16_t totp_spdm_m_support_aead_algo =
    SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_256_GCM |
    SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_CHACHA20_POLY1305;

static uint16_t totp_spdm_m_support_key_schedule_algo =
    SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH;

static uint32_t totp_spdm_m_use_responder_capability_flags =
    (0 |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CACHE_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PUB_KEY_ID_CAP */
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHAL_CAP |
    // SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_NO_SIG | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_SIG */
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_SIG | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_NO_SIG */
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_FRESH_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCRYPT_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MAC_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MUT_AUTH_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP |
    // SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT */
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER */
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCAP_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_UPD_CAP |
    SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP |
    // SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PUB_KEY_ID_CAP | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP */
    0);

/*
* Global SHA-1/TOTP variables and defines
* TODO: mover para arquivo separado
*/
#define HASH_LENGTH 20
#define BLOCK_LENGTH 64
#define SHA1_K0 0x5a827999
#define SHA1_K20 0x6ed9eba1
#define SHA1_K40 0x8f1bbcdc
#define SHA1_K60 0xca62c1d6
union _buffer {
    uint8_t b[BLOCK_LENGTH];
    uint32_t w[BLOCK_LENGTH/4];
} buffer;
union _state {
    uint8_t b[HASH_LENGTH];
    uint32_t w[HASH_LENGTH/4];
} state;
uint8_t bufferOffset;
uint32_t byteCount;
uint8_t keyBuffer[BLOCK_LENGTH];
uint8_t innerHash[HASH_LENGTH];
uint8_t sha1InitState[] = {
    0x01,0x23,0x45,0x67, // H0
    0x89,0xab,0xcd,0xef, // H1
    0xfe,0xdc,0xba,0x98, // H2
    0x76,0x54,0x32,0x10, // H3
    0xf0,0xe1,0xd2,0xc3  // H4
};
uint8_t* _hmacKey;
uint8_t _keyLength;
uint8_t _timeZoneOffset;
uint32_t _timeStep;


/*
* Perf helper functions and formats
*/

#define NUM_PERF_EVENTS 3
enum { CYCLES = 0, TASK_CLOCK = 1, INSTRUCTIONS = 2 };

struct read_format {
 uint64_t nr;            /* The number of events */
 // uint64_t time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
 uint64_t time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
 struct {
     uint64_t value;     /* The value of the event */
     // uint64_t id;        /* if PERF_FORMAT_ID */
 } values[NUM_PERF_EVENTS];
};

static long
usb_totp_perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                int cpu, int group_fd, unsigned long flags)
{
    int ret;

    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,
                    group_fd, flags);
    return ret;
}

return_status usb_totp_init_perf_events(int *fd_cycles, int *fd_taskclock, int *fd_instructions);
return_status usb_totp_init_perf_events(int *fd_cycles, int *fd_taskclock, int *fd_instructions) {
  struct perf_event_attr pe;

  memset(&pe, 0, sizeof(struct perf_event_attr));
  pe.size = sizeof(struct perf_event_attr);
  pe.disabled = 1;
  pe.exclude_kernel = 1;
  pe.exclude_hv = 1;
  pe.exclude_guest = 1;
  pe.read_format = PERF_FORMAT_GROUP |
                   // PERF_FORMAT_TOTAL_TIME_ENABLED |
                   PERF_FORMAT_TOTAL_TIME_RUNNING |
                   // PERF_FORMAT_ID;
                   0;

  pe.type = PERF_TYPE_HARDWARE;
  pe.config = PERF_COUNT_HW_CPU_CYCLES;

  *fd_cycles = usb_totp_perf_event_open(&pe, 0, -1, -1, 0);
  if (*fd_cycles == -1) {
      fprintf(stderr, "Error opening perf leader fd %llx\n", pe.config);
      return RETURN_DEVICE_ERROR;
  }

  pe.type = PERF_TYPE_SOFTWARE;
  pe.config = PERF_COUNT_SW_TASK_CLOCK;

  *fd_taskclock = usb_totp_perf_event_open(&pe, 0, -1, *fd_cycles, 0);
  if (*fd_taskclock == -1) {
      fprintf(stderr, "Error opening perf TASK_CLOCK fd %llx\n", pe.config);
      return RETURN_DEVICE_ERROR;
  }

  pe.type = PERF_TYPE_HARDWARE;
  pe.config = PERF_COUNT_HW_INSTRUCTIONS;

  *fd_instructions = usb_totp_perf_event_open(&pe, 0, -1, *fd_cycles, 0);
  if (*fd_instructions == -1) {
      fprintf(stderr, "Error opening perf INSTRUCTIONS fd %llx\n", pe.config);
      return RETURN_DEVICE_ERROR;
  }

  return RETURN_SUCCESS;
}

/* 
* Device-specific defines
*/

#define TYPE_USB_TOTP_SPDM "usb-totp-spdm"
#define USB_TOTP_SPDM_DEV(obj) OBJECT_CHECK(USBTotpSpdmState, (obj), TYPE_USB_TOTP_SPDM)

/* 
* USB description functions and data objects.
* Set bInterfaceClass, bDeviceClass, etc. to 0x00, representing a
* general device (https://www.usb.org/defined-class-codes),
* and idVendor e idProduct to 0x0666 for easy identification.
*/

enum {
    STR_MANUFACTURER = 1,
    STR_SERIALNUMBER,
};

static const USBDescStrings desc_strings = {
    [STR_MANUFACTURER]    = "666",
    [STR_SERIALNUMBER]    = "666",
};

static const USBDescIface desc_iface0 = {
    .bInterfaceNumber              = 0,
    .bNumEndpoints                 = 2,
    .bInterfaceClass               = 0x00,
    .bInterfaceSubClass            = 0x00,
    .bInterfaceProtocol            = 0x00,
    .eps = (USBDescEndpoint[]) {
        {
            .bEndpointAddress      = USB_DIR_IN | 0x01,
            .bmAttributes          = USB_ENDPOINT_XFER_BULK,
            .wMaxPacketSize        = MAX_PACKET_SIZE,
        },{
            .bEndpointAddress      = USB_DIR_OUT | 0x02,
            .bmAttributes          = USB_ENDPOINT_XFER_BULK,
            .wMaxPacketSize        = MAX_PACKET_SIZE,
        },
    }
};

static const USBDescDevice desc_device = {
    .bcdUSB                        = 0x0200,
    .bDeviceClass                  = 0x00,
    .bDeviceSubClass               = 0x00,
    .bDeviceProtocol               = 0x00,
    .bMaxPacketSize0               = 8,
    .bNumConfigurations            = 1,
    .confs = (USBDescConfig[]) {
        {
            .bNumInterfaces        = 1,
            .bConfigurationValue   = 1,
            .bmAttributes          = USB_CFG_ATT_ONE,
            .bMaxPower             = 50,
            .nif = 1,
            .ifs = &desc_iface0,
        },
    },
};

static const USBDesc desc_totp_spdm = {
    .id = {
        .idVendor          = 0x0666,
        .idProduct         = 0x0666,
        .bcdDevice         = 0x0400,
        .iManufacturer     = STR_MANUFACTURER,
        .iSerialNumber     = STR_SERIALNUMBER,
    },
    .full = &desc_device,
    .str  = desc_strings,
};

/*
* SHA-1 and TOTP code adapted from:
* https://github.com/Netthaw/TOTP-MCU
* TODO: could be more properly implemented as a separate file
*/

static void init(void) {
    memcpy(state.b,sha1InitState,HASH_LENGTH);
    byteCount = 0;
    bufferOffset = 0;
}

static void hashBlock(void) {
    uint8_t i;
    uint32_t a,b,c,d,e,t;

    a=state.w[0];
    b=state.w[1];
    c=state.w[2];
    d=state.w[3];
    e=state.w[4];
    for (i=0; i<80; i++) {
        if (i>=16) {
            t = buffer.w[(i+13)&15] ^ buffer.w[(i+8)&15] ^ buffer.w[(i+2)&15] ^ buffer.w[i&15];
            buffer.w[i&15] = rol32(t,1);
        }
        if (i<20) {
            t = (d ^ (b & (c ^ d))) + SHA1_K0;
        } else if (i<40) {
            t = (b ^ c ^ d) + SHA1_K20;
        } else if (i<60) {
            t = ((b & c) | (d & (b | c))) + SHA1_K40;
        } else {
            t = (b ^ c ^ d) + SHA1_K60;
        }
        t+=rol32(a,5) + e + buffer.w[i&15];
        e=d;
        d=c;
        c=rol32(b,30);
        b=a;
        a=t;
    }
    state.w[0] += a;
    state.w[1] += b;
    state.w[2] += c;
    state.w[3] += d;
    state.w[4] += e;
}

static void addUncounted(uint8_t data) {
    buffer.b[bufferOffset ^ 3] = data;
    bufferOffset++;
    if (bufferOffset == BLOCK_LENGTH) {
        hashBlock();
        bufferOffset = 0;
    }
}

static void writeData(uint8_t data) {
    ++byteCount;
    addUncounted(data);

    return;
}

static void writeArray(uint8_t *buffer, uint8_t size){
    while (size--) {
            writeData(*buffer++);
    }
}

static void pad(void) {
    // Implement SHA-1 padding (fips180-2 ��5.1.1)

    // Pad with 0x80 followed by 0x00 until the end of the block
    addUncounted(0x80);
    while (bufferOffset != 56) addUncounted(0x00);

    // Append length in the last 8 bytes
    addUncounted(0); // We're only using 32 bit lengths
    addUncounted(0); // But SHA-1 supports 64 bit lengths
    addUncounted(0); // So zero pad the top bits
    addUncounted(byteCount >> 29); // Shifting to multiply by 8
    addUncounted(byteCount >> 21); // as SHA-1 supports bitstreams as well as
    addUncounted(byteCount >> 13); // byte.
    addUncounted(byteCount >> 5);
    addUncounted(byteCount << 3);
}

static uint8_t* result(void) {
    // Pad to complete the last block
    pad();

    // Swap byte order back
    uint8_t i;
    for (i=0; i<5; i++) {
        uint32_t a,b;
        a=state.w[i];
        b=a<<24;
        b|=(a<<8) & 0x00ff0000;
        b|=(a>>8) & 0x0000ff00;
        b|=a>>24;
        state.w[i]=b;
    }

    // Return pointer to hash (20 characters)
    return state.b;
}

#define HMAC_IPAD 0x36
#define HMAC_OPAD 0x5c

static void initHmac(const uint8_t* key, uint8_t keyLength) {
    uint8_t i;
    memset(keyBuffer,0,BLOCK_LENGTH);
    if (keyLength > BLOCK_LENGTH) {
        // Hash long keys
        init();
        for (;keyLength--;) writeData(*key++);
        memcpy(keyBuffer,result(),HASH_LENGTH);
    } else {
        // Block length keys are used as is
        memcpy(keyBuffer,key,keyLength);
    }
    // Start inner hash
    init();
    for (i=0; i<BLOCK_LENGTH; i++) {
        writeData(keyBuffer[i] ^ HMAC_IPAD);
    }
}

static uint8_t* resultHmac(void) {
    uint8_t i;
    // Complete inner hash
    memcpy(innerHash,result(),HASH_LENGTH);
    // Calculate outer hash
    init();
    for (i=0; i<BLOCK_LENGTH; i++) writeData(keyBuffer[i] ^ HMAC_OPAD);
    for (i=0; i<HASH_LENGTH; i++) writeData(innerHash[i]);
    return result();
}

// Init the library with the private key, its length and the timeStep duration
static void TOTP(uint8_t* hmacKey, uint8_t keyLength, uint32_t timeStep) {
    _hmacKey = hmacKey;
    _keyLength = keyLength;
    _timeStep = timeStep;
}

// Generate a code, using the number of steps provided
static uint32_t getCodeFromSteps(uint32_t steps) {
    // STEP 0, map the number of steps in a 8-bytes array (counter value)
    uint8_t _byteArray[8];
    _byteArray[0] = 0x00;
    _byteArray[1] = 0x00;
    _byteArray[2] = 0x00;
    _byteArray[3] = 0x00;
    _byteArray[4] = (uint8_t)((steps >> 24) & 0xFF);
    _byteArray[5] = (uint8_t)((steps >> 16) & 0xFF);
    _byteArray[6] = (uint8_t)((steps >> 8) & 0XFF);
    _byteArray[7] = (uint8_t)((steps & 0XFF));

    // STEP 1, get the HMAC-SHA1 hash from counter and key
    initHmac(_hmacKey, _keyLength);
    writeArray(_byteArray, 8);
    uint8_t* _hash = resultHmac();

    // STEP 2, apply dynamic truncation to obtain a 4-bytes string
    uint32_t _truncatedHash = 0;
    uint8_t _offset = _hash[20 - 1] & 0xF;
    uint8_t j;
    for (j = 0; j < 4; ++j) {
        _truncatedHash <<= 8;
        _truncatedHash  |= _hash[_offset + j];
    }

    // STEP 3, compute the OTP value
    _truncatedHash &= 0x7FFFFFFF;    //Disabled
    _truncatedHash %= 1000000;

    return _truncatedHash;
}

// Generate a code, using the timestamp provided
static uint32_t getCodeFromTimestamp(uint32_t timeStamp) {
    uint32_t steps = timeStamp / _timeStep;
    return getCodeFromSteps(steps);
}

// end of SHA-1/TOTP functions

#if !TOTP_KEY_FROM_MS
/*
* Crytpgraphically Secure Pseudo-Random Number Generator
* code adapted from:
* https://github.com/Duthomhas/CSPRNG
* TODO: could be more properly implemented as a separate file
*/

typedef void* CSPRNG;

typedef union {
    CSPRNG object;
    FILE*  urandom;
} CSPRNG_TYPE;

/*
* Returns a new CSPRNG object, 0 on error.
*/
static CSPRNG csprng_create(void){
    CSPRNG_TYPE csprng;
    csprng.urandom = fopen("/dev/urandom", "rb");
    return csprng.object;
}

/*
* Fills $dest with $size bytes worth of random data.
* Returns 1 on succes, 0 on failure.
*/
static int csprng_get(CSPRNG object, void* dest, unsigned long long size){
    CSPRNG_TYPE csprng;
    csprng.object = object;
    return (csprng.urandom) && (fread((char*)dest, 1, size, csprng.urandom) == size);
}

/*
* Destroy an existing CSPRNG object. Returns 0.
* Use it as:
* v = csprng_destroy( v );
*/
static CSPRNG csprng_destroy(CSPRNG object)  {
    CSPRNG_TYPE csprng;
    csprng.object = object;
    if (csprng.urandom) fclose(csprng.urandom);
    return 0;
}

// End of CSPRNG functions
#endif // !TOTP_KEY_FROM_MS

/*
* Checks if an array is full of zeroes
* Returns 1 if all elements are 0, 0 otherwise
*/
static int arr_is_zero(uint8_t *arr, size_t size) 
{
    int i;
    for(i = 0; i < size; i++) {
        if(arr[i] != 0){
            return 0;
        }
    }
    return 1;
}

/* 
* Needs to exist and invoke usb_desc_handle_control
*/
static void usb_totp_spdm_handle_control(USBDevice *dev, USBPacket *p,
               int request, int value, int index, int length, uint8_t *data)
{
    // USBTotpSpdmState *s = (USB_TOTP_SPDM_DEV *)dev;
    int ret;
    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);
    if (ret >= 0) {
        return;
    }
}

/*
* Gets a TOTP code with the current timestamp.
*/
static uint32_t get_totp(void){
    USB_SPDM_PRINT("totp_key:\n");
#if USB_SPDM_DEBUG
    for (int i = 0; i < sizeof(totp_key); i++){
        printf("%02X ", totp_key[i]);
    }
    printf("\n");
#endif
    TOTP(totp_key, SPDM_SHA_SIZE, TOTP_TIMESTEP); // key, key size, timestep in s

    return getCodeFromTimestamp((unsigned)time(NULL));
}

/*
* SPDM callback function to set data and create responses related to
* certificates. Requires the connection to be at
* SPDM_CONNECTION_STATE_NEGOTIATED.
*/
static void usb_totp_spdm_server_callback (IN void *SpdmContext) {
    USB_SPDM_PRINT("usb_totp_spdm_server_callback\n");
    static boolean AlgoProvisioned = FALSE;
    boolean Res;
    return_status Status;
    spdm_data_parameter_t Parameter;
    uint8_t Index;
    uint8_t Data8;
    uint16_t Data16;
    uint32_t Data32;
    uint8_t m_use_slot_count = 3;
    uint8_t m_use_slot_id = 0;
    // uint32_t m_use_measurement_hash_algo;
    uint32_t m_use_asym_algo;
    uint32_t m_use_hash_algo;
    uint16_t m_use_req_asym_algo;
    uintn DataSize;
    uintn HashSize;
    void *Hash;
    void *Data;
    
    if (AlgoProvisioned) {
        return;
    }

    zero_mem (&Parameter, sizeof(Parameter));
    Parameter.location = SPDM_DATA_LOCATION_CONNECTION;

    DataSize = sizeof(Data32);
    spdm_get_data (SpdmContext, SPDM_DATA_CONNECTION_STATE, &Parameter, &Data32, &DataSize);
    if (Data32 != SPDM_CONNECTION_STATE_NEGOTIATED) {
#if USB_SPDM_DEBUG
        printf ("Data32 != SPDM_CONNECTION_STATE_NEGOTIATED: %u\n", Data32);
#endif
        return;
    }

    // AlgoProvisioned = TRUE;
    atomic_set(&AlgoProvisioned, TRUE);

    // DataSize = sizeof(Data32);
    // spdm_get_data (SpdmContext, SPDM_DATA_MEASUREMENT_HASH_ALGO, &Parameter, &Data32, &DataSize);
    // m_use_measurement_hash_algo = Data32;
    DataSize = sizeof(Data32);
    spdm_get_data (SpdmContext, SPDM_DATA_BASE_ASYM_ALGO, &Parameter, &Data32, &DataSize);
    m_use_asym_algo = Data32;
    DataSize = sizeof(Data32);
    spdm_get_data (SpdmContext, SPDM_DATA_BASE_HASH_ALGO, &Parameter, &Data32, &DataSize);
    m_use_hash_algo = Data32;
    DataSize = sizeof(Data16);
    spdm_get_data (SpdmContext, SPDM_DATA_REQ_BASE_ASYM_ALG, &Parameter, &Data16, &DataSize);
    m_use_req_asym_algo = Data16;

    Res = read_responder_public_certificate_chain (m_use_hash_algo, m_use_asym_algo, &Data, &DataSize, NULL, NULL);
    if (Res) {
        zero_mem (&Parameter, sizeof(Parameter));
        Parameter.location = SPDM_DATA_LOCATION_LOCAL;
        Data8 = m_use_slot_count;
        spdm_set_data (SpdmContext, SPDM_DATA_LOCAL_SLOT_COUNT, &Parameter, &Data8, sizeof(Data8));

        for (Index = 0; Index < m_use_slot_count; Index++) {
            Parameter.additional_data[0] = Index;
            spdm_set_data (SpdmContext, SPDM_DATA_LOCAL_PUBLIC_CERT_CHAIN, &Parameter, Data, DataSize);
        }
        // do not free it
    }

    if (m_use_slot_id == 0xFF) {
        Res = read_requester_public_certificate_chain (m_use_hash_algo, m_use_req_asym_algo, &Data, &DataSize, NULL, NULL);
        if (Res) {
            zero_mem (&Parameter, sizeof(Parameter));
            Parameter.location = SPDM_DATA_LOCATION_LOCAL;
            spdm_set_data (SpdmContext, SPDM_DATA_PEER_PUBLIC_CERT_CHAIN, &Parameter, Data, DataSize);
            // Do not free it.
        }
    } else {
        Res = read_requester_root_public_certificate (m_use_hash_algo, m_use_req_asym_algo, &Data, &DataSize, &Hash, &HashSize);
        if (Res) {
            zero_mem (&Parameter, sizeof(Parameter));
            Parameter.location = SPDM_DATA_LOCATION_LOCAL;
            spdm_set_data (SpdmContext, SPDM_DATA_PEER_PUBLIC_ROOT_CERT_HASH, &Parameter, Hash, HashSize);
            // Do not free it.
        }
    }

    if (Res) {
        Data8 = SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_ENCAP_REQUEST;
        if (Data8 != 0) {
            Data8 |= SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED;
        }
        Parameter.additional_data[0] = m_use_slot_id; // ReqSlotNum;
        Parameter.additional_data[1] = SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH; // MeasurementHashType;
        spdm_set_data (SpdmContext, SPDM_DATA_MUT_AUTH_REQUESTED, &Parameter, &Data8, sizeof(Data8));

        Data8 = (SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_ENCAP_REQUEST & 0x1);
        spdm_set_data (SpdmContext, SPDM_DATA_BASIC_MUT_AUTH_REQUESTED, &Parameter, &Data8, sizeof(Data8));
    }

    Status = spdm_set_data (SpdmContext, SPDM_DATA_PSK_HINT, NULL, (void *) TEST_PSK_HINT_STRING, sizeof(TEST_PSK_HINT_STRING));
    if (RETURN_ERROR(Status)) {
        printf ("SpdmSetData - %x\n", (uint32_t)Status);
    }

    return;
}

/*
* QEMU thread function. Will execute continually and look for incoming
* or outgoing SPDM requests.
*/
static void *usb_totp_spdm_io_thread(void *opaque)
{
    USBTotpSpdmState *s = opaque;
    return_status status;
    uint8 request_code;

    // perf variables
    int local_cyc, local_clock, local_inst;
    struct read_format rf;
    usb_totp_init_perf_events(&local_cyc, &local_clock, &local_inst);
    static uint64_t cycle_accum = 0;
    static uint64_t clock_accum = 0;
    static uint64_t instr_accum = 0;
    static uint8_t should_sum = 0;

    while (true) {
        USB_SPDM_PRINT("usb_totp_spdm_io_thread() loop\n");
        qemu_mutex_lock(&spdm_io_mutex);
        if (!spdm_receive_is_ready) {
            qemu_cond_wait(&spdm_io_cond, &spdm_io_mutex);
        }
        spdm_receive_is_ready = 0;

        // printf("\n");
        // for (int i = 0; i < 10; i++)
        //     printf("%02X ", spdm_buf[i]);
        // printf("\n");

        qemu_mutex_unlock(&spdm_io_mutex);

        ioctl(local_cyc, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP);
        ioctl(local_cyc, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);

        status = spdm_responder_dispatch_message (s->spdm_context);

        ioctl(local_cyc, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
        read(local_cyc, &rf, sizeof(rf));

        request_code = ((spdm_message_header_t*)(((spdm_context_t *)s->spdm_context)->last_spdm_request))->request_response_code;

        if (request_code == SPDM_GET_VERSION) {
            cycle_accum = clock_accum = instr_accum = 0;
            should_sum = 1;
        }

        // printf("%02X,\t%lu cycles,\t%lu ns,\t%lu instructions\n", request_code,
        //   rf.values[CYCLES].value, rf.values[TASK_CLOCK].value, rf.values[INSTRUCTIONS].value);

        if (should_sum) {
            cycle_accum += rf.values[CYCLES].value;
            clock_accum += rf.values[TASK_CLOCK].value;
            instr_accum += rf.values[INSTRUCTIONS].value;
        }
        if (request_code == SPDM_FINISH || request_code == SPDM_PSK_FINISH) {
            should_sum = 0;
            printf("Handshake%s,\t%lu cycles,\t%lu ns,\t%lu instructions\n",
                (request_code == SPDM_PSK_FINISH? " PSK":""), cycle_accum, clock_accum, instr_accum);
        }
        if (request_code == SPDM_HEARTBEAT) {
            printf("Heartbeat,\t%lu cycles,\t%lu ns,\t%lu instructions\n",
                rf.values[CYCLES].value, rf.values[TASK_CLOCK].value, rf.values[INSTRUCTIONS].value);
        }

        if (status == RETURN_SUCCESS) {
            // load certificates and stuff
            usb_totp_spdm_server_callback (s->spdm_context);
        } else {
            printf("SpdmResponderDispatchMessage error: %llX\n", status);
        }

    }

    close(local_cyc);
    close(local_clock);
    close(local_inst);

    return NULL;
}

/*
* Response to a vendor-defined request. Specifically, gets the
* random number sent by the SPDM requester, creates its own
* random number, and sends it back.
*/
static return_status spdm_device_get_response(
            IN void *spdm_context,
            IN uint32 *session_id,
            IN boolean is_app_message,
            IN uintn request_size,
            IN void *request,
            IN OUT uintn *response_size,
            OUT void *response) {

    int local_cyc, local_clock, local_inst;
    struct read_format rf;
    usb_totp_init_perf_events(&local_cyc, &local_clock, &local_inst);

    USB_SPDM_PRINT("spdm_device_get_response \n");

    // Check the request size
    // If zero, this is a periodic TOTP check
    // Also check if a TOTP key has been set previously
    if (request_size <= TOTP_RANDOM_NUM_SIZE && !arr_is_zero(totp_key, TOTP_RANDOM_NUM_SIZE)){
        ioctl(local_cyc, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
        USB_SPDM_PRINT("Periodic TOTP check\n");
        char totp_str[TOTP_HEX_SIZE];   // max TOTP size is 5 hex
        uint32_t totp_code;

        totp_code = get_totp();
        USB_SPDM_PRINT("totp_code: %d\n", totp_code);
        
        // To add data to the packet vector, convert it to hex
        // with sprintf
        sprintf(totp_str, "%x", totp_code);

        // Set first byte as this flag
        *((uint8_t*)response) = MCTP_MESSAGE_TYPE_VENDOR_DEFINED_IANA;

        // Copy TOTP value to response after the first byte
        memcpy(response + 1, &totp_str, TOTP_HEX_SIZE*sizeof(char));
        *response_size = TOTP_HEX_SIZE*sizeof(char) + 1;

        ioctl(local_cyc, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
        read(local_cyc, &rf, sizeof(rf));

        printf("TOTP gen value,\t%lu cycles,\t%lu ns,\t%lu instructions\n",
                rf.values[CYCLES].value, rf.values[TASK_CLOCK].value, rf.values[INSTRUCTIONS].value);
    }
    // Otherwise, this is a TOTP key defining message
    else {

        printf("SPDM_SHA_SIZE %u\n", SPDM_SHA_SIZE);
        ioctl(local_cyc, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
        USB_SPDM_PRINT("TOTP key definition\n");

#if TOTP_KEY_FROM_MS
        if (session_id != NULL) {
            // derive TOTP key from master secret
            spdm_secured_message_context_t* secured_message_context = spdm_get_secured_message_context_via_session_id(
                                                spdm_context,
                                                *session_id);

            // maybe it would be better to use the spdm_secured_message_export_master_secret() from the API
            // but it would cost some performance
            spdm_hkdf_expand(   secured_message_context->base_hash_algo,
                                secured_message_context->handshake_secret.export_master_secret,
                                secured_message_context->hash_size,
                                (uint8_t*)"TOTPKEY", 7,
                                totp_key,
                                SPDM_SHA_SIZE);

            // printf("TOTP_KEY:");
            // for (int tempi = 0; tempi < SPDM_SHA_SIZE; tempi++)
            //     printf(" %02x", totp_key[tempi]);
            // printf("\n");

            *((uint8_t*)response) = MCTP_MESSAGE_TYPE_VENDOR_DEFINED_IANA;
            *response_size = SPDM_SHA_SIZE + 1;

        }
#else // TOTP_KEY_FROM_MS
        CSPRNG rng;
        uint64_t random_local_num;
        uint8_t temp_totp_key[SPDM_SHA_SIZE];     // Generated TOTP key as uint64_t
        uint8_t temp_key_array[TOTP_RANDOM_NUM_SIZE*2];

        // Fetch the original value as a uint64_t
        uint64_t temp = *((uint64_t*)(request + 1));

        // Generate a random number locally
        do{
            rng = csprng_create();
        } while (!rng);
        csprng_get (rng, &random_local_num, sizeof(random_local_num));
        rng = csprng_destroy(rng);

        // Concatenate both random numbers and hash them
        memcpy(temp_key_array, &random_local_num, TOTP_RANDOM_NUM_SIZE);
        memcpy(temp_key_array + TOTP_RANDOM_NUM_SIZE, &temp, TOTP_RANDOM_NUM_SIZE);

        // use HKDF to create TOTP key
        hkdf_sha256_expand(temp_key_array, TOTP_RANDOM_NUM_SIZE*2,
                            (const uint8 *) "TOTPKEY", sizeof("TOTPKEY"),
                            temp_totp_key, SHA256_DIGEST_SIZE);

        // Saving generated key on global array
        memcpy(totp_key, &temp_totp_key, SPDM_SHA_SIZE);

        // Set first byte as this flag
        *((uint8_t*)response) = MCTP_MESSAGE_TYPE_VENDOR_DEFINED_IANA;

        // copy TOTP key to response after the first byte
        memcpy(response + 1, &temp_totp_key, SPDM_SHA_SIZE);
        *response_size = SPDM_SHA_SIZE + 1;
#endif // TOTP_KEY_FROM_MS
        next_message_totp_check = true;

        ioctl(local_cyc, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
        read(local_cyc, &rf, sizeof(rf));

        printf("TOTP genkey,\t%lu cycles,\t%lu ns,\t%lu instructions (TOTP_KEY_FROM_MS = %u)\n",
                rf.values[CYCLES].value, rf.values[TASK_CLOCK].value, rf.values[INSTRUCTIONS].value, TOTP_KEY_FROM_MS);
    }

    close(local_cyc);
    close(local_clock);
    close(local_inst);

    return RETURN_SUCCESS;
}

/*
* Send SPDM messages
*/
static return_status spdm_device_send_message(
            IN void *spdm_context,
            IN uintn request_size,
            IN void *request,
            IN uint64 timeout) {
    
    USB_SPDM_PRINT("spdm_device_send_message\n");
    if (request_size > sizeof(spdm_buf)) {
        printf("RequestSize too large %llu\n", request_size);
        return RETURN_DEVICE_ERROR;
    }
#if USB_SPDM_DEBUG
    int i;
    printf("request: \n");
    for (i = 0; i < request_size; i++) {
        printf("%02X ", ((uint8_t*)request)[i]);
        if ((i+1)%8 == 0){
            printf("\n");
        }
    }
    if (i%8 != 0){
        printf("\n");
    }
    printf("---\n");
    printf("request_size: %llu\n", request_size);
#endif

    qemu_mutex_lock(&spdm_io_mutex);
    spdm_buf_size = request_size;
    memcpy(spdm_buf, request, request_size);
    spdm_send_is_ready = 1;
    USB_SPDM_PRINT("spdm_send_is_ready\n");
    qemu_cond_signal(&spdm_io_cond);
    qemu_mutex_unlock(&spdm_io_mutex);
    return RETURN_SUCCESS;
}

/*
* Receive SPDM message
*/
static return_status spdm_device_receive_message(
            IN void *spdm_context,
            IN OUT uintn *response_size,
            IN OUT void *response,
            IN uint64 timeout){
    USB_SPDM_PRINT("spdm_device_receive_message\n");
    if (*response_size < atomic_read(&spdm_buf_size)) {
        printf("*response_size too small %llu\n", *response_size);
        return RETURN_DEVICE_ERROR;
    }
    qemu_mutex_lock(&spdm_io_mutex);

    const uint8_t GET_VERSION[] = {0x05, 0x10, 0x84, 0x00, 0x00};
    // Hax to for all sessions to be cleared
    // not clearing causes problems after MAX_SPDM_SESSION_COUNT VM reboots due to session vector overflow
    // could not find a more appropriate location to do it (does not work on virtio_blk_reset)
    if (!memcmp(GET_VERSION, spdm_buf, sizeof(GET_VERSION))) {
        // printf("Got get_version: clearing all sessions...\n");
        spdm_session_info_t *session_info;
        uintn index;

        session_info = ((spdm_context_t*)spdm_context)->session_info;
        for (index = 0; index < MAX_SPDM_SESSION_COUNT; index++) {
            session_info[index].session_id = (INVALID_SESSION_ID & 0xFFFF);
        }
    }


    current_spdm_receive_message = true;
    next_message_totp_check = false;
    *response_size = spdm_buf_size;
    memcpy(response, spdm_buf, *response_size);
    qemu_mutex_unlock(&spdm_io_mutex);

#if USB_SPDM_DEBUG
    int i;
    printf("response: \n");
    for (i = 0; i < spdm_buf_size; i++) {
        printf("%02X ", ((uint8_t*)response)[i]);
        if ((i+1)%8 == 0){
            printf("\n");
        }
    }
    if (i%8 != 0){
        printf("\n");
    }
    printf("---\n");
    printf("*response_size: %llu\n", *response_size);
    printf("spdm_buf_size: %u\n", spdm_buf_size);
#endif

    USB_SPDM_PRINT("spdm_device_receive_message end\n");
    return RETURN_SUCCESS;
}

/*
* Hex to decimal conversion
* Source: https://stackoverflow.com/a/11068850
*/
static const long hextable[] = { 
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1, 0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,-1,10,11,12,13,14,15,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
};

/** 
 * @brief convert a hexidecimal string to a signed long
 * will not produce or process negative numbers except 
 * to signal error.
 * 
 * @param hex without decoration, case insensitive. 
 * 
 * @return -1 on error, or result (max (sizeof(long)*8)-1 bits)
 */
static long hexdec(unsigned const char *hex) {
    long ret = 0; 
    while (*hex && ret >= 0) {
        ret = (ret << 4) | hextable[*hex++];
    }
    return ret; 
}

/*
* Fetches SPDM request size from specific byte from the request itself
*/
static size_t get_size_from_request(void* data) {
    uint8_t size_hex[LEN_HEX_SIZE];
    unsigned long size_dec;

    memcpy(size_hex, data, LEN_HEX_SIZE*sizeof(uint8_t));
    size_dec = hexdec(size_hex);
    return size_dec;
}

/*
* Data handling function, invoked every time an URB is being
* sent or received
*/
static void usb_totp_spdm_handle_data(USBDevice *dev, USBPacket *p)
{
    USBTotpSpdmState *s = (USBTotpSpdmState *) dev;
    int len, extra_len;
    bool first = false;
    bool last = false;
    uint8_t size_out[LEN_HEX_SIZE];
#if USB_SPDM_DEBUG
    int i;
#endif
    USB_SPDM_PRINT("usb_totp_spdm_handle_data\n");

    switch (p->pid) {

    // dados saindo do driver
    case USB_TOKEN_OUT:     // PID 225
        USB_SPDM_PRINT("USB_TOKEN_OUT\n");

        qemu_mutex_lock(&spdm_io_mutex);

        // First transfer
        if (s->full_transfer_size_out == 0){
            USB_SPDM_PRINT("USB_TOKEN_OUT - first transfer\n");
            first = true;
            
            // Copy size data to size array
            usb_packet_copy(p, size_out, LEN_HEX_SIZE);
            
            // Get actual size
            s->full_transfer_size_out = get_size_from_request(size_out);
            spdm_buf_size = s->full_transfer_size_out;
            USB_SPDM_PRINT("spdm_buf_size: %u\n", spdm_buf_size);
            
            // Length for next usb_packet_copy will be either the full
            // remaining buffer (single packet transfer), or
            // MAX_PACKET_SIZE - LEN_HEX_SIZE (multiple packet transfer)
            if (s->full_transfer_size_out <= MAX_PACKET_SIZE - LEN_HEX_SIZE){
                // Single packet transfer
                last = true;
                len = s->full_transfer_size_out;
            }
            else {
                // First packet of multiple packet transfer
                last = false;
                len = MAX_PACKET_SIZE - LEN_HEX_SIZE;
            }
        }
        // Not the first transfer
        else {
            USB_SPDM_PRINT("USB_TOKEN_OUT - not the first transfer\n");
            first = false;

            // Last packet in multiple packet transfer
            if (s->current_transfer_size_out + MAX_PACKET_SIZE >= s->full_transfer_size_out){
                last = true;
                len = s->full_transfer_size_out - s->current_transfer_size_out;
            }
            else {
                last = false;
                len = MAX_PACKET_SIZE;
            }
        }

        // Copy packet data to spdm_buf with current_transfer_size_out as offset
        usb_packet_copy(p, spdm_buf + s->current_transfer_size_out, len);

#if USB_SPDM_DEBUG
        printf("s->current_transfer_size_out = %u\n", s->current_transfer_size_out);
        for (i = 0; i < len; i++){
            printf("%02X ", spdm_buf[i + s->current_transfer_size_out]);
            if ((i+1)%8 == 0){
                printf("\n");
            }
        }
        if (i%8 != 0){
            printf("\n");
        }
#endif

        // Last transfer
        if (last){
            USB_SPDM_PRINT("USB_TOKEN_OUT - last transfer\n");
            // Reset all variables specific to this transfer
            s->current_transfer_size_out = 0;
            s->full_transfer_size_out = 0;

            // Signal SPDM that the message is ready
            spdm_receive_is_ready = 1;
            qemu_cond_signal(&spdm_io_cond);
        }
        // Not the last transfer
        else {
            USB_SPDM_PRINT("USB_TOKEN_OUT - not the last transfer\n");
            // Add the size that was written to spdm_buf
            // to current_transfer_size_out
            s->current_transfer_size_out += len;
        }

        qemu_mutex_unlock(&spdm_io_mutex);
        USB_SPDM_PRINT("USB_TOKEN_OUT END\n");
        break;

    // dados chegando no driver
    case USB_TOKEN_IN:      // PID 105
        USB_SPDM_PRINT("USB_TOKEN_IN\n");
        if (current_spdm_receive_message){
            char new_header[SPDM_SEND_OFFSET];

            qemu_mutex_lock(&spdm_io_mutex);
            if (!spdm_send_is_ready) {
                qemu_cond_wait(&spdm_io_cond, &spdm_io_mutex);
            }

            // First transfer
            if (s->current_transfer_size_in == 0){
                first = true;
                USB_SPDM_PRINT("USB_TOKEN_IN - first transfer\n");
                // add length to first positions of spdm_buf
                char len_str[LEN_HEX_SIZE];
                sprintf(len_str, "%x", spdm_buf_size);

                // If it's 64 bytes, it breaks, so do this
                int headersize = (spdm_buf_size == 60) ? (LEN_HEX_SIZE - 1)*sizeof(char) : LEN_HEX_SIZE*sizeof(char);
                memcpy(&(new_header)[0], len_str, headersize);

                // Copy header to packet
                usb_packet_copy(p, new_header, headersize);
            }
            else {
                first = false;
                USB_SPDM_PRINT("USB_TOKEN_IN - not the first transfer\n");
                int extra_header_len = (spdm_buf_size == 60) ? (SPDM_SEND_OFFSET - 1) : SPDM_SEND_OFFSET;
                extra_len = MIN(spdm_buf_size - s->current_transfer_size_in, extra_header_len);

                // Copy spare data from extra_buffer_in
                usb_packet_copy(p, s->extra_buffer_in, extra_len);
                s->current_transfer_size_in += extra_len;
            }

            // len is the minimum value between the remainig data to be transfered
            // (spdm_buf_size - s->current_transfer_size_in) and the
            // max size subtracted by the original header, SPDM_SEND_OFFSET
            int iov_with_header = (spdm_buf_size == 60) ? (p->iov.size - (SPDM_SEND_OFFSET - 1)) : p->iov.size - SPDM_SEND_OFFSET;
            len = MIN(spdm_buf_size - s->current_transfer_size_in, iov_with_header);
            USB_SPDM_PRINT("len: %u\n", len);
            USB_SPDM_PRINT("spdm_buf_size: %u\n", spdm_buf_size);
            USB_SPDM_PRINT("s->current_transfer_size_in: %u\n", s->current_transfer_size_in);

            // Copy spdm_buf to packet, right after new_header
            usb_packet_copy(p, spdm_buf + s->current_transfer_size_in, len);
            s->current_transfer_size_in += len;

            // Not the last transfer
            if (s->current_transfer_size_in < spdm_buf_size) {
                last = false;
                USB_SPDM_PRINT("USB_TOKEN_IN - not the final transfer\n");
                // Copy spare data to extra_buffer_in
                memcpy(s->extra_buffer_in,
                        spdm_buf + s->current_transfer_size_in,
                        MIN(spdm_buf_size - s->current_transfer_size_in, SPDM_SEND_OFFSET));
            }
            // Final transfer
            else {
                last = true;
                // If it is the last transfer of a combined one,
                // add back the original header size
                if (!first){
                    usb_packet_copy(p, spdm_buf + s->current_transfer_size_in - SPDM_SEND_OFFSET, SPDM_SEND_OFFSET);
                }
                USB_SPDM_PRINT("USB_TOKEN_IN - final transfer\n");
                s->current_transfer_size_in = 0;
                spdm_send_is_ready = 0;
                USB_SPDM_PRINT("spdm_send_is_ready = 0\n");
                if (next_message_totp_check){
                    current_spdm_receive_message = false;
                }
            }

    #if USB_SPDM_DEBUG
            printf("iov final: \n");
            for (i = 0; i < p->iov.size; i++){
                printf("%02X ", ((uint8_t *)p->iov.iov->iov_base)[i]);
                if ((i+1)%8 == 0){
                    printf("\n");
                }
            }
            if (i%8 != 0){
                printf("\n");
            }
    #endif

            qemu_mutex_unlock(&spdm_io_mutex);
            USB_SPDM_PRINT("USB_TOKEN_IN END\n");
        }
        // TOTP message without SPDM
        else{

            int local_cyc, local_clock, local_inst;
            struct read_format rf;
            usb_totp_init_perf_events(&local_cyc, &local_clock, &local_inst);

            ioctl(local_cyc, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
            USB_SPDM_PRINT("Periodic TOTP check\n");
            char totp_str[TOTP_HEX_SIZE];   // max TOTP size is 5 hex
            uint32_t totp_code;

            totp_code = get_totp();
            USB_SPDM_PRINT("totp_code: %d\n", totp_code);
            
            // To add data to the packet vector, convert it to hex
            // with sprintf
            sprintf(totp_str, "%x", totp_code);

            // Copy TOTP value to response
            usb_packet_copy(p, totp_str, TOTP_HEX_SIZE);

            ioctl(local_cyc, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
            read(local_cyc, &rf, sizeof(rf));

            printf("TOTP gen value,\t%lu cycles,\t%lu ns,\t%lu instructions\n",
                    rf.values[CYCLES].value, rf.values[TASK_CLOCK].value, rf.values[INSTRUCTIONS].value);

            close(local_cyc);
            close(local_clock);
            close(local_inst);

        }
        break;
    
    default:
        printf("default\n");
        printf("p->pid: %d\n", p->pid);
        break;
    }

    USB_SPDM_PRINT("---\n");
}

/*
* Initializes SPDM context and sets relevant data and functions
* for future use.
*/
static void init_spdm(USBTotpSpdmState *s){
    uint8_t data8;
    uint16_t data16;
    uint32_t data32;
    uint8_t m_use_version = SPDM_MESSAGE_VERSION_11;
    uint8_t m_use_secured_message_version = SPDM_MESSAGE_VERSION_11;
    spdm_data_parameter_t parameter;
    spdm_version_number_t spdm_version;

    USB_SPDM_PRINT("init_spdm\n");
    s->spdm_context = (void *)malloc(spdm_get_context_size());
    if (s->spdm_context == NULL) {
        printf("Failed to initialize SPDM context.\n");
    }

    // Initialize context variable
    spdm_init_context(s->spdm_context);

    // Set functions for setting and receiving SPDM messages
    spdm_register_device_io_func(
            s->spdm_context,
            spdm_device_send_message,
            spdm_device_receive_message);
    spdm_register_transport_layer_func(
            s->spdm_context,
            spdm_transport_mctp_encode_message,
            spdm_transport_mctp_decode_message);
    
    if (m_use_version != SPDM_MESSAGE_VERSION_11) {
        zero_mem(&parameter, sizeof(parameter));
        parameter.location = SPDM_DATA_LOCATION_LOCAL;
        spdm_version.major_version = (m_use_version >> 4) & 0xF;
        spdm_version.minor_version = m_use_version & 0xF;
        spdm_version.alpha = 0;
        spdm_version.update_version_number = 0;
        spdm_set_data(s->spdm_context, SPDM_DATA_SPDM_VERSION, &parameter,
                  &spdm_version, sizeof(spdm_version));
    }

    if (m_use_secured_message_version != SPDM_MESSAGE_VERSION_11) {
        zero_mem(&parameter, sizeof(parameter));
        if (m_use_secured_message_version != 0) {
            parameter.location = SPDM_DATA_LOCATION_LOCAL;
            spdm_version.major_version =
                (m_use_secured_message_version >> 4) & 0xF;
            spdm_version.minor_version =
                m_use_secured_message_version & 0xF;
            spdm_version.alpha = 0;
            spdm_version.update_version_number = 0;
            spdm_set_data(s->spdm_context,
                      SPDM_DATA_SECURED_MESSAGE_VERSION,
                      &parameter, &spdm_version,
                      sizeof(spdm_version));
        } else {
            spdm_set_data(s->spdm_context,
                      SPDM_DATA_SECURED_MESSAGE_VERSION,
                      &parameter, NULL, 0);
        }
    }
    
    zero_mem(&parameter, sizeof(parameter));
    parameter.location = SPDM_DATA_LOCATION_LOCAL;

    data8 = 0;
    spdm_set_data(s->spdm_context, SPDM_DATA_CAPABILITY_CT_EXPONENT,
              &parameter, &data8, sizeof(data8));
    data32 = totp_spdm_m_use_responder_capability_flags;
    spdm_set_data(s->spdm_context, SPDM_DATA_CAPABILITY_FLAGS, &parameter,
              &data32, sizeof(data32));

    data8 = totp_spdm_m_support_measurement_spec;
    spdm_set_data(s->spdm_context, SPDM_DATA_MEASUREMENT_SPEC, &parameter,
              &data8, sizeof(data8));
    data32 = totp_spdm_m_support_measurement_hash_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_MEASUREMENT_HASH_ALGO, &parameter,
              &data32, sizeof(data32));
    data32 = totp_spdm_m_support_asym_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_BASE_ASYM_ALGO, &parameter,
              &data32, sizeof(data32));
    data32 = totp_spdm_m_support_hash_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_BASE_HASH_ALGO, &parameter,
              &data32, sizeof(data32));
    data16 = totp_spdm_m_support_dhe_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_DHE_NAME_GROUP, &parameter,
              &data16, sizeof(data16));
    data16 = totp_spdm_m_support_aead_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_AEAD_CIPHER_SUITE, &parameter,
              &data16, sizeof(data16));
    data16 = totp_spdm_m_support_req_asym_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_REQ_BASE_ASYM_ALG, &parameter,
              &data16, sizeof(data16));
    data16 = totp_spdm_m_support_key_schedule_algo;
    spdm_set_data(s->spdm_context, SPDM_DATA_KEY_SCHEDULE, &parameter, &data16,
              sizeof(data16));

    qemu_mutex_init(&spdm_io_mutex);
    qemu_cond_init(&spdm_io_cond);
    spdm_buf_size = 0;
    spdm_send_is_ready = 0;
    spdm_receive_is_ready = 0;

    spdm_register_get_response_func(
            s->spdm_context,
            spdm_device_get_response);

    qemu_thread_create(&s->spdm_io_thread,
                "spdm_io_usb_device",
                usb_totp_spdm_io_thread,
                s,
                QEMU_THREAD_JOINABLE);
}

/* 
* This function initializes the device, and must invoke
* usb_desc_create_serial and usb_desc_init, and get attached
* via usb_device_attach(dev, &error_abort);
*/
static void usb_totp_spdm_realize(USBDevice *dev, Error **errp)
{
    USBTotpSpdmState *s = USB_TOTP_SPDM_DEV(dev);
    Error *local_err = NULL;

    usb_desc_create_serial(dev);
    usb_desc_init(dev);
    dev->auto_attach = 0;

    usb_check_attach(dev, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }

    memset(totp_key, 0, sizeof(totp_key));
    s->current_transfer_size_in = 0;
    s->current_transfer_size_out = 0;
    s->full_transfer_size_out = 0;
    init_spdm(s);

    usb_device_attach(dev, &error_abort);
}

static const VMStateDescription vmstate_usb_totp_spdm = {
    .name = TYPE_USB_TOTP_SPDM,
    .unmigratable = 1,
};

/*
* Properties array
*/

static Property totp_spdm_properties[] = {
    DEFINE_PROP_END_OF_LIST(),
};

/*
* Initialization functions
* The .name variable in the TypeInfo defines the name
* that must be used invoking the device from the qemu command
*/
static void usb_totp_spdm_class_initfn(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

    uc->realize        = usb_totp_spdm_realize;
    uc->handle_control = usb_totp_spdm_handle_control;
    uc->handle_data    = usb_totp_spdm_handle_data;
    uc->product_desc   = "Dispositivo USB para comunicação TOTP + SPDM";
    uc->usb_desc       = &desc_totp_spdm;
    dc->props = totp_spdm_properties;
    dc->vmsd = &vmstate_usb_totp_spdm;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
}

static const TypeInfo totp_spdm_info = {
    .name          = TYPE_USB_TOTP_SPDM,
    .parent        = TYPE_USB_DEVICE,
    .instance_size = sizeof(USBTotpSpdmState),
    .class_init    = usb_totp_spdm_class_initfn,
};

static void usb_totp_spdm_register_types(void)
{
    type_register_static(&totp_spdm_info);
    usb_legacy_register(TYPE_USB_TOTP_SPDM, "totp-spdm", NULL);
}

type_init(usb_totp_spdm_register_types)
